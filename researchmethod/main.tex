%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{IEEEtran}  % Comment this line out
                                                          % if you need a4paper
%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4
                                                          % paper

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\title{\LARGE \bf
clang sanitize reduce instruments on sequential access
}


\author{P\'eter K\'okai and Attila Kiss}


\usepackage[backend=biber]{biblatex}
\addbibresource{ref.bib}
\let\cite\parencite

\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
In languages with programmatic memory management (no garbage collector) the life-time and scope of those memory addresses is an ongoing battle; as theses error could cause system corruption or security breaches. One type of such tools that does analysis in run-time, and such tools most likely going to slow down the original execution speed. The execution speed matters where timers, and external timeouts causing different execution path than without such tool. One of such tools is the embedded address sanitize, which instruments the compiled code at memory store and access. The aim of this paper is to investigate if the number of store, access instrumentation can be lowered, and if such optimization could provide significant performance gain.
\end{abstract} \hspace{10pt}

%TC:ignore
\small \textbf{Keywords} LLVM, address sanitizer, asan, store-load instrument reduce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}
The naive approach and a good first candidate is to instrument every instruction that is either store or access.In some cases it is possible to reduce the number of access, access or store, store check

\section{Related Work}
Many memory detection tool exists, while those having the same goal of uncovering memory related coding errors. They may differ in techniques, quality and performance manner. One of the uprising star of such technique is compile time instrumenting called sanitizing, to be more precious address sanitizing \cite{serebryany2012addresssanitizer} that is first introduced into the LLVM\cite{lattner2004llvm}\cite{lattner2006introduction}\cite{lattner2007llvm} ecosystem.

The address sanitizer(ASAN) is recognised and used from small to big projects, probably listing all of them would be impossible. Also the usage of ASAN is not limited to user space processes that proofs the effort from Tizen OS\cite{barinov2017applying}. Of course Tizen was not the only kernel, linux\cite{samsonov2013new} also has an option named kernel address sanitizer (short: KSAN).

Combining ASAN with different tools could expedite the time needed to find the failures. Finding security issues like Heartbeat\cite{alkazimi2016heartbleed} is kinda close to trivial combining fuzzers\cite{bohme2017directed} with sanitizer.


\addtolength{\textheight}{-12cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{APPENDIX}

Appendixes should appear before the acknowledgment.

\section*{ACKNOWLEDGMENT}




\printbibliography

\end{document}

