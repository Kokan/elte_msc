%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt]{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{minted}
\usepackage{xcolor}



\title{\LARGE \bf
LLVM address sanitizer specific optimalizations
}


\author{P\'eter K\'okai \and
        Attila Kiss}
%
\authorrunning{P. K\'okai et al.}

\institute{Eotrovs Lorand University, \and
\email{kokaipeter@gmail.com, kiss@inf.elte.hu}
}
%


\usepackage[backend=biber]{biblatex}
\addbibresource{ref.bib}
\let\cite\parencite

\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
The address sanitizer since introduced became a very popular memory related error detection, while there are other tools covering almost the same set of detection, the sanitzer by instrumenting the executable binary itself can be inferior in performance. For some application the performance is critical, thus cannot use properly a more traditional like memory detection tools.
The aim is to find possible ways for performance improvement in the sanitizer code instrumentor.


\end{abstract} \hspace{10pt}

\small \textbf{Keywords} LLVM, address sanitizer, asan, store-load instrument reduce

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}


One of the major advantages of ASAN its performance, the avarage slowdown is 1.75 according to this research\cite{serebryany2012addresssanitizer}. The natural performance gain comes from the nature of instrumenting the code in compile time, and not changing in runtime. Moving a lot of computation to the compiler. Additionally in the LLVM sanitizers are implemented as a LLVM IR\cite{llvm-ir} transformation, just like the optimizers in common named called Passes. There are different type of Passes, despite of their types each Pass is executed in a semi-random order. The sanitizer type of Passes (Address, Memory, Thread, Undefined, etc) are executed in the last place, thus instructions that are removed by optimization are ignored without any effort. As well as the different type of Passes are not required to know about the sanitizer specific implementations.

This effectivly also means that the code generated by the sanitizer is not optimized at all. The question could come naturally if there is a need for further optimizing for those code. One of the factor is the actuall code created by the ASAN itself, and its context the rest of the code. At least the focus in this paper going to be on improvement that can be only done with wide range of code.

The following sections are going to rely heavily on knowladge about LLVM\cite{lattner2008llvm} and its intermediate representation of LLVM IR\cite{llvm-ir}. The LLVM/clang was choosen exactly because of its LLVM IR based design opposed to gcc.

\section{Related works}

The address sanitizer(ASAN) is one of the tool helping the developpers detecting memory related issues such as leak, use after lifespan or inproper memory access like buffer overflow. Those could effectivly lead not only crashing application, but even security issues. Even with exhaused testing those type of issues could be still hidden as favorable executions could work on process own memory and only strange not as expected. It is shown in many reaserch that combining a wide range of sanitizer could improve existing testing methods. Studies like combining with fuzzing\cite{alkazimi2016heartbleed}\cite{bohme2017directed}.

\section{Concepts and problems}


Let us have a look on the proposed\cite{serebryany2012addresssanitizer} improvements. Starting with only one that is already implemented and used in the original measurements. In the following example it is easy to understood that multiple read/store access check is not required.

\subsection{Incrementing variable}

\begin{minted}{c}
void increment(int *a) {
 (*a)++;
}
\end{minted}

Compiling the code with: clang -emit-llvm -S -O2
\begin{minted}{c}
define dso_local void @inc(i32* nocapture) #0 {
  %2 = load i32, i32* %0, align 4
  %3 = add nsw i32 %2, 1
  store i32 %3, i32* %0, align 4
  ret void
}
\end{minted}

Accessing the same address twice, once for reading from it and the next time to write the result. Therefore checking if the address is still not posined does not improve the detection. 
Enabling the sanitizer: clang -emit-llvm -S -O2 -fsanitize=address -mllvm --asan-instrumentation-with-call-threshold=0\footnote{The sanitizer is forced to use function call instead of replacing instruments in order to fit the code into the page.}

\begin{minted}{c}
define dso_local void @inc(i32* nocapture %a) #0 {
entry:
  %0 = ptrtoint i32* %a to i64
  call void @__asan_load4(i64 %0)
  %1 = load i32, i32* %a, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %a, align 4
  ret void
}
\end{minted}

This works like expected, one could wonder the extense of this kind of checking. It is really easy to construct the following still very simple and similuar code:

\begin{minted}{c}
void inc(int *a) {
  int tmp = *a;
  *a = tmp + 1;
}
\end{minted}

But the result going to be very different:

\begin{minted}{c}
define dso_local void @inc(i32* nocapture %a) #0 {
entry:
  %0 = ptrtoint i32* %a to i64
  call void @__asan_load4(i64 %0)
  %1 = load i32, i32* %a, align 4
  %add = add nsw i32 %1, 1
  %2 = ptrtoint i32* %a to i64
  call void @__asan_store4(i64 %2)
  store i32 %add, i32* %a, align 4
  ret void
}
\end{minted}

Even with this simple example it is easy to see the limitation of the above example.

\subsection{Instrument only array first and last access}

In the next example store/load operation is done sequantially on an array. It is possible and currently every load/store operation is checked. There are cases where it is possible to use less check, just like in case of memset or memcpy. Those calls effectivly are replaced with a boundary check a[0] and a[n-1].
\begin{minted}{c}
void d_memset(int *a, int value, int n) {
  for (int i = 0; i < n; ++i) {
    a[i] = value;
  }
}
\end{minted}
In this case the goal is define exactly under which condition using the intervall check is correct, and which case it must instrument every operation.


\section{Experiments}

\subsection{Naiv approach}

The nice thing about LLVM that it can produce LLVM IR as a result, additionally it can parse it as an input as well. One could simply ask clang to emit llvm ir, and after that step simple re-execute all of those optimizers on top of it with opt.

By checking the examples above with the afformentioned idea it is possible to identify some change in the code itself. Examint further thoses changes, it is possible to clasify into three different section:
\begin{itemize}
 \item convert function to tail call
 \item change the order from and, add, trunc to trunc, and, add
 \item reverse the branch from true: error handling false: fast path
\end{itemize}

Depending on the decision that sanitizer makes (currently based on the number of instrumention it must take) it could either inject the code itself or just call a function. But either way as just the opt suggested converting those function calls by default tail call is a fine move.

The benefit of working on a 8bit number instead of a 64bit can be doubtful on a 64 bit system, but can be appritiated on a 32 bit system.

The change in the branch is intresting from the branch prediction point of view, the error handling branch performance does not concern us as it also going to terminate the application and only going to happen at most onece. While the fast path should be triggered all the time.

\section{Results}
\section{Conclusion}
\section{Future works}



TODO/draft/ignore:
* Implementation is LLVM/clang based (not gcc, but probably could be applied)
* Reference the current implementation \cite{serebryany2012addresssanitizer} and how it works
* Reference \cite{serebryany2012addresssanitizer} ideas from this feature section
* Explain that current sanitizer is executed after optimizer (that gives a lot of gain without effort in sanitizer), explain why this section cannot be build as a simple optimization




\addtolength{\textheight}{-12cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Acknowledgment}



\printbibliography

\end{document}

